\chapter{Introduction}

\section{Background}
In this section we summarize some key papers and their significance to the
project.

We may also include a brief introduction to HoTT, but maybe that's better suited
to \ref{ch/hott}.

% this should maybe go in a ``related works'' section
\subsection{A Categorical Theory of Patches}
A Categorical Theory of Patches~\cite{Categorical2013} defines a category of
files and patches, such that a merge is a pushout. To ensure a merge is always
possible they first construct the category $\mathcal{L}$ of files and patches,
and then its conservative cocompletion $\mathcal{P}$.

$\mathcal{P}$ contains all finite colimits -- and in particular all pushouts --
so the merge of a span is always defined. The paper's chief achievement is the
explicit construction of this category and these pushouts.

Interesting insights I'm not sure how to incorporate:
\begin{itemize}
\item the construction of $\mathcal{P}$ can be understood as the addition of \emph{partially} ordered
  files to $\mathcal{L}$.
\item ``flattening'' these partial orders leads to cyclic graphs. On editing
  text~\cite{editing2014} objects, but maybe not correctly
\item the poset structure of $\mathcal{L}$ and $\mathcal{P}$ is given explicitly
  by $\mathcal{G}$ and the nerve functor $N_{\_}$ (!!).
\end{itemize}

(maybe mention Pijul~\cite{Pijul} (if so, figure out the relationship to ~\cite{Categorical2013}))
(maybe some figures go here)

\subsection{Patch Theory (Darcs)}
Here we discuss several proposed formalisms for a the patch theory employed by
Darcs~\cite{Darcs}. \cite{Lynagh2006, Sittampalam2005, Dagit2009} all attempt to
describe Darcs' patch theory. (focus on Lynagh, I think)

% Lynagh's Algebra of Patches
\textcite{Lynagh2006} proposes an ``algebra of patches'' as a theoretical
basis for the Darcs~\cite{Darcs} version control system.

In this model a repository state is a set of updates (called \emph{patches}, but
we want to avoid that ambiguity) and a patch is a change to this set. For
example pulling the repository $\{c\}$ into the repository $\{a,b\}$ results in
a new repository $\{a,b\} \cup \{c\} = \{a,b,c\}$.

Patches are only applicable to one repository state, and result in a new state.
If they are compatible, we may string them together into a \emph{patch sequence}.
Denoting the previous example patch by $P$ and the ``do-nothing'' patch by $Id$
we have $\{a,b\}P\{a,b,c\}Id\{a,b,c\}$ -- pulling $\{c\}$ followed by doing
nothing. The repository state may be omitted from sequences.

Finally a notion of \emph{commutation} of patches is defined. We say patches $A$
and $B$ commute if the span $\bullet \xleftarrow{A} \bullet \xrightarrow{B}
\bullet$ can be expanded to the following commuting square:

\begin{center}
  \begin{tikzcd}
  \bullet \arrow[dd, "A"'] \arrow[rr, "B"] &  & \bullet \arrow[dd, "A'", dashed] \\
   &&\\
  \bullet \arrow[rr, "B'"', dashed]        &  & \bullet                         
  \end{tikzcd}
\end{center}

and write $AB \comm B'A'$.

We have four axioms for patches and commutation:
\begin{enumerate}
  \item Commutativity (lol) (3.1): $AB \comm B'A' \iff B'A' \comm AB$
  \item Invertibility (3.2): for each $A$ there is an $A^{-1}$ s.t
    $AA^{-1}=A^{-1}A=Id$
  \item Inv-cong (3.3): $AB \comm B'A' \iff A^{-1}B' \comm BA'^{-1}$
  \item Circular (3.5/6): performing all pairwise commutations in a sequence
    gets us back to the beginning (or, a horrible equation)
\end{enumerate}

With these axioms and definitions we can merge the span $\bullet \xleftarrow{A} \bullet \xrightarrow{B}
\bullet$ by filling in the square:

\begin{center}
\begin{tikzcd}
\bullet \arrow[dd, "A"', bend right] \arrow[rr, "B"]&  & \bullet\\
&&\\
\bullet \arrow[rr, "B'"', dashed] \arrow[uu, "A^{-1}"', dashed, bend right] &  & \bullet \arrow[uu, "A^{-1}'"', dashed]
\end{tikzcd}
\end{center}
We have $A^{-1}B \comm B'A^{-1}'$ and define $merge A\;B = AB'$. It is not clear
to me from this diagram why the inverse(s) is needed

\subsection{Homotopical Patch Theory}
Homotopical Patch Theory~\cite{Angiuli2016} gives a formulation of patch theory
in homotopy type theory. A patch theory is represented by a higher
inductive type, and its interpretation by a function out of this type.

By representing repository state as points and patches as paths in a higher
inductive type, the groupoid structure of the patch theory comes ``for free''.
Paths come with composition, and by the groupoid laws this composition is
associative, unital, and respects inverses. Additionally, functions (which are functors)
respect this structure so any interpretation must also validate the groupoid
laws.

Patch laws are represented by paths between paths (squares? disks?
2D-somethings). For example we may want the application of two independent
patches to commute -- this is done with a patch law.

While the HIT formulation gives a lot ``for free'', it also has some drawbacks.
In particular, the requirement that all patches have inverses causes some
problems. The workaround is to ``type'' patches with the history they are
applicable to. This allows Angiuli et al. to define a merge operation in terms
on only the ``forward'' patches, but leads to a fairly complex theory even for
relatively simple settings.

% cut this if we don't do more work on it
An interesting feature of Angiuli et al.'s patch theories is that the type of
repositories must be contractible. Since patches are represented by paths, any
point can be retracted along them. As such, all repositories are -- in a sense
-- ``the same'' and we need better notions of
``sub-homotopical''~\cite{Angiuli2016} computations to reason about their differences.

\subsection{Path Spaces of Higher Inductive Types}
Path Spaces of Higher Inductive Types in Homotopy Type
Theory~\cite{kraus2019path} provides an induction principle for paths in
coequalizers. This is extremely useful, since we want to define functions out of
spans in HITs. ($\leftarrow$ rework this sentence)

Summarizing this will be very technical, and may become its own chapter if I
successfully formalize the proof in cubical agda. Otherwise it goes here.