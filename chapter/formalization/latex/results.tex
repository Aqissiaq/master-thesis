\section{Computational Results}

Having implemented several patch theories we can have a look at what they actually do.
In this section we do exactly that, considering some concrete examples of repositories,
patches and merges for the three [TWO IF RICHER DOESN'T WORK OUT] theories.

\begin{itemize}
\item rewrite?
\item trans/hcomp problems
  \item mention Brunerie number (and the smaller Brunerie nr.)
\end{itemize}

\subsection{Elementary Patch Computations}

First, consider the elementary patch theory implemented in \autoref{sec/elementary-hpt}.
Recall that this theory has one type of repositories -- the integers -- and one patch
-- \texttt{add1}.

\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--cubical}\AgdaSpace{}%
\AgdaPragma{--allow-unsolved-metas}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{results}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{elementary-hpt}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Data.Int}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Data.Nat}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Data.Sigma}\<%
\end{code}

By the usual path operations we obtain some more patches: the "do nothing"-patch \texttt{noop},
the inverse \texttt{sub1} and compositions like \texttt{add2}.
\begin{code}%
%
\>[2]\AgdaFunction{noop}\AgdaSpace{}%
\AgdaFunction{sub1}\AgdaSpace{}%
\AgdaFunction{add2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\<%
\\
%
\>[2]\AgdaFunction{noop}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\>[2]\AgdaFunction{sub1}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\<%
\\
%
\>[2]\AgdaFunction{add2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\<%
\end{code}

All of these suggestively named patches behave as one might expect:
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{noop}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{sub1}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{0}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{add2}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{add1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{sub1}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\end{code}

We can generalize further and create patches to add or subtract any integer,
and these also compute as expected.
\begin{code}%
%
\>[2]\AgdaComment{--\ maybe\ hide\ this\ definition}\<%
\\
%
\>[2]\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℤ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Patch}\<%
\\
%
\>[2]\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{pos}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{noop}\<%
\\
%
\>[2]\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{pos}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{pos}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{negsuc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sub1}\<%
\\
%
\>[2]\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{negsuc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sub1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{negsuc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{addN}\AgdaSpace{}%
\AgdaNumber{22}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaNumber{20}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{42}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaNumber{22}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaNumber{42}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaNumber{20}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\end{code}

Clearly, this patch theory is a fully functioning calculator (for integer addition and subtraction),
but the detour through algebraic topology takes a computational toll.
The following proof typechecks, but it takes about 2 minutes.
\begin{code}%
%
\>[2]\AgdaComment{--\ this\ takes\ 1m47s\ to\ typecheck}\<%
\\
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ :\ apply\ (addN\ 1000)\ 0\ ≡\ 1000}\<%
\\
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ =\ refl}\<%
\end{code}

\begin{figure}
\begin{centering}
\begin{tikzcd}
  & n \arrow[ld, "p"'] \arrow[rd, "q"] &\\
  x \arrow[rd, "p'"'] && y \arrow[ld, "q'"] \\
  & z&
\end{tikzcd}
\caption{\texttt{merger}}
\label{fig:elementary-merger}
\end{centering}
\end{figure}

Finally, we look at \texttt{merge}. The function \texttt{merger} neatly computes the result of
merging patches $p$ and $q$ from the original repository $n$ as shown in
\autoref{fig:elementary-merger}.
\begin{code}%
%
\>[2]\AgdaFunction{merger}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℤ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℤ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaDatatype{ℤ}\<%
\\
%
\>[2]\AgdaFunction{merger}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}%
\>[135I]\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[135I]%
\>[21]\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[21]\AgdaSymbol{(}\AgdaBound{p'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{p'}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\end{code}

Applying \texttt{merger} to a few test cases, it too behaves as expected.
The resulting two integers are always equal, which is exactly what we want merge to do.
Of course this is a consequence of the general case proven by \texttt{reconcile} in
\autoref{sec/elementary-hpt}, but it is good to see it in practice.
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{merger}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaFunction{noop}\AgdaSpace{}%
\AgdaFunction{sub1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{-1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{-1}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{merger}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{addN}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{addN}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{-3}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\end{code}

\subsection{Patch Computations with Laws}

Next we examine the patch theory with laws and its patch optimizer from \autoref{sec/laws-noTrunc-noIndep}.
In this theory the repository is a fixed-length vector of strings, and the patches permute the string
at a given index.
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{laws-hpt-noTrunc-noIndep}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Foundations.Prelude}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{using}\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{refl}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡⟨\AgdaUnderscore{}⟩\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∎}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Foundations.GroupoidLaws}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin.Base}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties.Core}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Decidable.Core}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Agda.Builtin.Unit}\<%
\end{code}

For concrete examples, consider the starting repository and patches:
\begin{code}%
%
\>[2]\AgdaFunction{repo}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{repoType}\<%
\\
%
\>[2]\AgdaFunction{repo}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaString{"hello"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"world"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{nop}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSpace{}%
\AgdaFunction{swap'}\AgdaSpace{}%
\AgdaFunction{comp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\<%
\\
%
\>[2]\AgdaFunction{nop}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaString{"nop"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↔}}\AgdaSpace{}%
\AgdaString{"nop"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{AT}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{swap}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaString{"hello"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↔}}\AgdaSpace{}%
\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{AT}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{swap'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaString{"world"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↔}}\AgdaSpace{}%
\AgdaString{"earthlings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{AT}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{comp}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{swap'}\<%
\end{code}

When applying these patches, we encounter the current limits of Cubical Agda.
In particular, \texttt{Vec String size} is a dependent family so \texttt{transp} and
\texttt{hcomp} do not compute on it. In the simple case of applying just one patch the issue
is resolved by \texttt{transportRefl : (x : A) → transport refl x ≡ x}, giving the expected result.
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{nop}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaFunction{repo}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaFunction{repo}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"world"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

In the case of composition it gets more difficult. The following cannot be proven by
\texttt{transportRefl}, since the computation gets stuck on the composition.
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{comp}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"earthlings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaHole{\{!!\}}\<%
\end{code}

Of course it is possible to compute the result by hand. Here we have some more information
about the patches being composed, and are able to eliminate the composition before applying the patch.
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nop}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}%
\>[33]\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"world"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}%
\>[297I]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nop}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{repo}\<%
\\
\>[.][@{}l@{}]\<[297I]%
\>[4]\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{R.noop}\AgdaSpace{}%
\AgdaString{"nop"}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\#}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{repo}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lUnit}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSpace{}%
\AgdaFunction{repo}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"world"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}

Applying the patches in order also produces the expected result.
[THIS SHOULD BE EQUIVALENT TO COMPOSITION, BUT IT'S REALLY HAIRY]
\begin{code}%
%
\>[2]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{swap'}\AgdaSpace{}%
\AgdaFunction{repo}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaString{"greetings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"earthlings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{apply}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"hello"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaString{"earthlings"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{transportRefl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

In addition to the patches themselves this theory includes an optimizer
making use of the patch laws. In our implementation these optimized patches come equipped
with a proof that they are equal to the original patch, so testing the results should not reveal
anything new -- nevertheless it is interesting to note just how slow these computations are.

All three exhaust the heap, taking on the order of 10s of minutes to do so, \texttt{swapOpt} is
particularly notable since \texttt{optimize} does not actually do anything.
The strings in \texttt{swap} are not equal, and so the patch should be kept as it is.
\begin{code}%
%
\>[2]\AgdaFunction{nopOpt}\AgdaSpace{}%
\AgdaFunction{swapOpt}\AgdaSpace{}%
\AgdaFunction{compOpt}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\<%
\\
%
\>[2]\AgdaFunction{nopOpt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{optimize}\AgdaSpace{}%
\AgdaFunction{nop}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{swapOpt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{optimize}\AgdaSpace{}%
\AgdaFunction{swap}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{compOpt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{optimize}\AgdaSpace{}%
\AgdaFunction{comp}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ :\ apply\ swapOpt\ repo\ ≡\ "greetings"\ ∷\ "world"\ ∷\ []}\<%
\\
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ =\ transportRefl\ "greetings"\ ∷\ "world"\ ∷\ []}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ :\ apply\ nopOpt\ repo\ ≡\ repo}\<%
\\
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ =\ transportRefl\ repo}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ :\ apply\ compOpt\ repo\ ≡\ "greetings"\ ∷\ "earthlings"\ ∷\ []}\<%
\\
%
\>[2]\AgdaComment{--\ \AgdaUnderscore{}\ =\ transportRefl\ \AgdaUnderscore{}}\<%
\end{code}
