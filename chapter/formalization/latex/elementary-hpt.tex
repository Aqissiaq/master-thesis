\section{An Elementary Patch Theory}\label{sec/elementary-hpt}

This section discusses the implementation of a very simple language of patches,
described in~\cite{Angiuli2016, section 4}.
\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--cubical}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{elementary-hpt}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Base}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Data.Int}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Core.Everything}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{I}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Foundations.Prelude}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{refl}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡⟨\AgdaUnderscore{}⟩\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∎}}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong₂}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\<%
\\
%
\>[2]\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.Foundations.Univalence}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{pathToEquiv}\AgdaSymbol{)}\<%
\end{code}

\subsection{The Circle as a Repository}

In the elementary patch theory the repository is a single integer and there is exactly one kind of patch:
adding one to the integer. This means the underlying type has one point constructor \texttt{num} and
one path \texttt{add1 : num ≡ num}.

The structure of this type may seem familiar - it is just the circle with its constructors renamed!
The cubical library already implements some HITs, including the circle so we will simply rename it and
its constructors.

In fact this implementation comes with a proof that the fundamental group of $S^1$ is the integers,
which contains many of the ingredients we will need. Specifically the loop space $ΩS^1$ is the type
of patches, and \texttt{helix : S¹ → Type} is precisely the interpretation of points in \texttt{R} as
types of repositories. Concretely \texttt{helix} maps \texttt{base} to the integers, and \texttt{loop}
to \texttt{ua} of the equivalence \texttt{ℤ ≃ ℤ} induced by the successor function.

\begin{code}%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Cubical.HITs.S1.Base}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{renaming}\AgdaSymbol{(}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaDatatype{S¹}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaDatatype{R}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{base}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{num}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{loop}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{add1}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ΩS¹}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{Patch}\<%
\\
%
\>[2]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{helix}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{I}\<%
\\
%
\>[2]\AgdaSymbol{)}\<%
\end{code}

With this machinery we can easily define an interpretation of patches as bijections on \texttt{ℤ}
by applying \texttt{I} along the patch and weakening the resulting path. For convenience we also
define a function to apply a patch to a given integer.
\begin{code}%
\>[0]\AgdaFunction{interp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℤ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≃}}\AgdaSpace{}%
\AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaFunction{interp}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{pathToEquiv}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{cong}\AgdaSpace{}%
\AgdaFunction{I}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℤ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{equivFun}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{interp}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}

\subsection{Merge}

Knowing that addition on the integers is commutative, merging two patches simply swaps
the order.

\begin{code}%
\>[0]\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{q}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

We now prove some properties of merge. Symmetry is essentially trivial, since swapping
the order twice gets us back to where we started.

\begin{code}%
\>[0]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[86I]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaBound{f1}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSpace{}%
\AgdaBound{g1}\AgdaSpace{}%
\AgdaBound{g2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[86I]%
\>[12]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{f1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{g1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g2}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f1}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{g2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g1}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaFunction{merge}\AgdaSpace{}%
\AgdaBound{p}\<%
\end{code}

Reconcile turns out to be more involved, but luckily some work is done for us.
It boils down to showing that composition of patches commutes, which relies on two facts:
\begin{enumerate}
  \item \texttt{intLoop} is a group homomorphism
  \item addition on the integers is commutative
\end{enumerate}

Both of these facts are in the standard library, so the task reduces to stitching them together.
First we convert the patches to explicit integers $n, m$ using the fact that \texttt{intLoop} is surjective.
We then apply the proof of commutativity for integers, and convert back to patches.

It is noteworthy that we were able to define \texttt{merge} without reference to explicit numbers,
but in order to prove its properties we require a "detour" into the integers.
\begin{code}%
\>[0]\AgdaFunction{intLoop-sur}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{intLoop-sur}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{decodeEncode}\AgdaSpace{}%
\AgdaInductiveConstructor{num}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{patch-comm}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[0]\AgdaFunction{patch-comm}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}%
\>[163I]\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{p-is-n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{intLoop-sur}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[.][@{}l@{}]\<[163I]%
\>[21]\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q-is-m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{intLoop-sur}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaKeyword{in}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{cong₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{p-is-n}\AgdaSpace{}%
\AgdaBound{q-is-m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{intLoop-hom}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+Comm}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{intLoop-hom}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaFunction{intLoop}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡⟨}}\AgdaSpace{}%
\AgdaFunction{cong₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym}\AgdaSpace{}%
\AgdaBound{q-is-m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym}\AgdaSpace{}%
\AgdaBound{p-is-n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaBound{q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}

With the commutativity of patches established, reconcile follows easily:

\begin{code}%
\>[0]\AgdaFunction{reconcile}%
\>[226I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{f1}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSpace{}%
\AgdaBound{g1}\AgdaSpace{}%
\AgdaBound{g2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Patch}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[226I]%
\>[10]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g2}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{f1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{g1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≡}}\AgdaSpace{}%
\AgdaBound{f2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaBound{g2}\<%
\\
\>[0]\AgdaFunction{reconcile}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}%
\>[252I]\AgdaBound{f1=g2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaField{snd}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[.][@{}l@{}]\<[252I]%
\>[18]\AgdaBound{g1=f2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{in}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{(}\AgdaFunction{cong₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{f1=g2}\AgdaSpace{}%
\AgdaBound{g1=f2}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∙}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{patch-comm}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\<%
\end{code}
