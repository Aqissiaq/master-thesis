\section{(Dependent) Type Theory}\label{sec/typetheory}
\begin{enumerate}
  \item (dependent) types in computer science
  \item type theories in math/foundations (the formal stuff)
  \item Agda syntax?
\end{enumerate}

Types are a familiar concept to the computer scientist. We are used to working
with data, and this data often has a \emph{data type} either explicitly or
implicitly. For example, \texttt{42} is an \texttt{int}, \texttt{'c'} is a
\texttt{char}, and \texttt{['a','b','c']} is a list of \texttt{char}s (henceforth
denoted \texttt{[char]}). We call
\texttt{int}, \texttt{char} and \texttt{[char]} \emph{types} and
\texttt{42}, \texttt{'c'}, \texttt{['a','b','c']} \emph{terms} of those types.
While this is a good basis for intuition, Type Theory (tm) is a bit different.

However, let us stick with the programming intuition to introduce a less
familiar concept: \emph{dependent} types. First, note that one of the types in
the previous paragraph is a bit different than the others: \text{['a','b','c']} is a
list \emph{of \texttt{char}s}. Similarly we could have lists of \texttt{int}s,
lists of \texttt{float}s or even lists of lists! Clearly ``lists'' comprises
many different types, depending on the type of their elements. We could call
\texttt{list} a family of types \emph{parametrized} by types. Such a family is
actually a whole collection of types -- one for each other type we can make
lists of.
Dependent types extend this idea by allowing families to be parametrized by
terms. Then we can create new and exciting types like \texttt{Vec 3} and
\texttt{Vec 4} -- the types of 3- and 4-dimensional vectors. Again \texttt{Vec} is
actually a whole collection of types -- one for each integer!

We now leave the familiar world of programming behind and venture in to the spooky
(but exciting) world of foundational mathematics.
\begin{equation}
  \begin{array}{c}
    \Gamma \vdash a : A \qquad \Gamma \vdash f : A \rightarrow B\\
    \hline
    \Gamma \vdash f(a) : B
  \end{array}
  \label{rule:example}
\end{equation}

In this new and wondrous world, a type theory is a system of \emph{inference
  rules} like \ref{rule:example} that can be used to make \emph{derivations}.

% anatomy of an inference rule
This particular inference rule is the elimination rule for function types. It
says that if $a$ is a term of type $A$ and $f$ is a function from $A$ to $B$,
then $f(a)$ is a term of type $B$. Let us take it apart.

The part above the line is a list of hypotheses, and the part below is the conclusion.

Each piece of the rule is called a \emph{judgement}. They consist of a
context, some expression and a $\vdash$ separating the two. In this example our judgements are:
\[\Gamma \vdash a : A\]
\begin{center}
``In any context $\Gamma$, $a$ is a term of type $A$''
\[\Gamma \vdash f : A \rightarrow B\]
``In any context $\Gamma$, $f$ is a function from $A$ to $B$''
\[\Gamma \vdash f(a) : B\]
``In any context $\Gamma$, $f(a)$ is a term of type $A$''
\end{center}

In fact these are all the same kind of judgement: a particular term ($a, f, f(a)$) is of a
particular type ($A, A \rightarrow B, B$). There are three other kinds of
judgements permitted in (Martin-LÃ¶f) type theory [NOTE: THESE ARE JUDGEMENTAL
EQUALITIES, DISTINCT FROM IDENTITY TYPES. MAKE CLEAR AND SETTLE ON SYNTAX]:
\begin{center}
  \[\Gamma \vdash A \; Type\]
  ``$A$ is a type.''
  \[\Gamma \vdash a \equiv b : A\]
  ``$a$ and $b$ are judgementally equal terms of type A.''
  \[\Gamma \vdash A \equiv B \; Type\]
  ``$A$ and $B$ are judgementally equal types.''
\end{center}

The judgement form $\Gamma \vdash A \; Type$ lets us formally define lists and
vectors. Lists are easy:
\begin{equation*}
  \begin{array}{c}
    \Gamma \vdash A \; Type \\
    \hline
    \Gamma \vdash [A] \; Type
  \end{array}
  \label{rule:lists}
\end{equation*}

This rule says ``if $A$ is a type, then lists of $A$ is a type''. Using
$\mathbb{N}$ for the type of natural numbers, vectors are very similar:
\begin{equation*}
  \begin{array}{c}
    \Gamma \vdash n : \mathbb{N} \\
    \hline
    \Gamma \vdash Vec (n) \; Type
  \end{array}
  \label{rule:lists}
\end{equation*}

Finally, we consider two important families of dependent types: $\Sigma$-types
(sometimes called ``dependent pairs'') and $\Pi$-types (``dependent
functions''). These are, respectively, pairs / functions where we let the
second projection / codomain depend on the value of the first projection /
domain. [THIS IS IMPRECISE AND USES WORDS WE HAVE NOT INTRODUCED].

\[
  \begin{array}[t]{c}
    \Gamma \vdash A \; Type \qquad x:A \vdash B(x) \; Type\\
    \hline
    \Gamma \vdash \Sigma_A B \; Type\\
  \end{array}
  \qquad
  \begin{array}[t]{c}
    \Gamma \vdash x:A \qquad \Gamma \vdash y : B(x)\\
    \hline
    \Gamma \vdash (x , y) : \Sigma_A B
  \end{array}
\]

This pair of rules (called an introduction/formation rule and an elimination(?) rule)
tells us that
\begin{enumerate}
\item if $A$ is a type, and $B$ is a type family over $A$ [INTRODUCE PHRASING?],
  then we can make the type $\Sigma_A B$ of dependent pairs
  \item if we have a term $x$ of type $A$ and a term $y$ of $B(x)$ we can create
    a term $(x,y)$ of type $\Sigma_A B$
\end{enumerate}

The analogous rules for dependent functions are:

\[
  \begin{array}[t]{c}
    \Gamma \vdash A \; Type \qquad x:A \vdash B(x) \; Type\\
    \hline
    \Gamma \vdash \Pi_A B \; Type\\
  \end{array}
  \qquad
  \begin{array}[t]{c}
    x:A \vdash b(x) : B(x)\\
    \hline
    \Gamma \vdash \lambda x.b(x) : \Pi_A B
  \end{array}
\]
When introducing a new type, we do so with a collection of rules. [NOT SURE
ABOUT THIS BIT, MAYBE EXPLAIN WITH $\Pi$ AND/OR $\Sigma$?]

\begin{equation}
  \begin{array}{c}
    \Gamma \vdash A \; Type \qquad \Gamma \vdash B \; Type\\
    \hline
    \Gamma \vdash A \rightarrow B \; Type
  \end{array}
  \label{rule:function-intro}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \Gamma \vdash f : A \rightarrow B\\
    \hline
    \Gamma, a : A \vdash f(a) : B
  \end{array}
  \label{rule:function-eval}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \Gamma \vdash B \; Type \qquad \Gamma, a : A \vdash f(a) : B\\
    \hline
    \Gamma \vdash \lambda x . f(x) : A \rightarrow B
  \end{array}
  \label{rule:function-abstr}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \Gamma \vdash f : A \rightarrow B\\
    \hline
    \Gamma \vdash \lambda x. f(x) \equiv f : A \rightarrow B
  \end{array}
  \label{rule:function-eta}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \Gamma \vdash B \; Type \qquad \Gamma, a : A \vdash f(a) : B\\
    \hline
    \Gamma, a : A \vdash (\lambda y . f(y))(a) \equiv f(a) : B
  \end{array}
  \label{rule:function-beta}
\end{equation}

Theses are (respectively, I will find a better way to label them) an
introduction rule, an elimination rule, lambda abstraction (what do we call this
one in general?) and two computation rules known as $\beta$- and $\eta$-reduction.